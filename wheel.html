<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Roue de la Fortune</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; }
    .wheel-container { 
      position: relative; 
      width: 400px; 
      height: 400px; 
      margin: 0 auto; 
    }
    .wheel { 
      transition: transform 3s cubic-bezier(.17,.67,.32,1.34); 
      width: 100%; 
      height: 100%; 
    }
    .pointer { 
      position: absolute; 
      top: -16px; 
      left: 50%; 
      transform: translateX(-50%); 
      width: 0; 
      height: 0; 
      border-left: 12px solid transparent; 
      border-right: 12px solid transparent; 
      border-top: 22px solid #22c55e; 
      z-index: 10; 
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.25)); 
    }
    @keyframes confetti {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .confetti { animation: confetti 3s linear forwards; }
  </style>
</head>
<body class="bg-gradient-to-b from-slate-900 to-slate-800 min-h-screen flex flex-col items-center justify-center p-4">
  <div class="max-w-2xl w-full text-center">
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-5xl font-bold text-white mb-4">üé∞ Roue de la Fortune</h1>
      <p class="text-xl text-slate-300">Tentez votre chance de gagner !</p>
    </div>

    <!-- Roue Container -->
    <div class="wheel-container mb-8">
      <canvas id="wheel" width="400" height="400" class="wheel rounded-full shadow-2xl"></canvas>
      <div class="pointer"></div>
    </div>

    <!-- Bouton Spin -->
    <div class="mb-6 flex justify-center">
      <button id="spinBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-xl shadow-xl text-lg transition-all duration-300 transform hover:scale-105 hover:shadow-2xl min-w-[200px]">
        üéØ Tourner la roue
      </button>
    </div>

    <!-- R√©sultat -->
    <div id="result" class="text-center text-white text-2xl font-semibold min-h-[3rem] mb-4"></div>

    <!-- Formulaire Gagnant -->
    <form id="winnerForm" class="hidden max-w-md mx-auto bg-white/10 backdrop-blur-sm rounded-xl p-6">
      <div class="space-y-4">
        <div>
          <label class="block text-white text-sm font-medium mb-2">Pr√©nom</label>
          <input type="text" id="prenom" required class="w-full px-4 py-3 rounded-lg bg-white/20 border border-white/30 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
        <div>
          <label class="block text-white text-sm font-medium mb-2">T√©l√©phone</label>
          <input type="tel" id="tel" required pattern="[0-9]{10}" class="w-full px-4 py-3 rounded-lg bg-white/20 border border-white/30 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
        <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl shadow-xl transition-all duration-300">
          ‚úÖ Valider mon gain
        </button>
      </div>
    </form>

    <!-- Confetti Container -->
    <div id="confettiContainer" class="fixed inset-0 pointer-events-none"></div>
  </div>

  <script>
    // Segments int√©gr√©s directement (pas d'import)
    const SEGMENTS = [
      'Perdu', 'Bloc-notes', 'Perdu', 'Stylo',
      'Perdu', 'Mini-lampe', 'Perdu', 'Gourde'
    ];
    const SEGMENT_COLORS = ['#ef4444', '#10b981', '#ef4444', '#3b82f6', '#ef4444', '#f59e0b', '#ef4444', '#8b5cf6'];
    const CADEAUX_INDICES = [1, 3, 5, 7]; // Bloc-notes, Stylo, Mini-lampe, Gourde
    const PERDU_INDICES = [0, 2, 4, 6];
    
    // Variables globales
    let spinCount = parseInt(localStorage.getItem("spinCount") || "0", 10);
    let spinning = false;
    let currentRotation = 0;
    const POINTER_OFFSET = 0; // Fl√®che fixe en haut

    // √âl√©ments DOM
    const wheel = document.getElementById('wheel');
    const ctx = wheel.getContext('2d');
    const spinBtn = document.getElementById('spinBtn');
    const result = document.getElementById('result');
    const winnerForm = document.getElementById('winnerForm');
    const confettiContainer = document.getElementById('confettiContainer');

    // V√©rification anti-triche
    if (!sessionStorage.getItem('avisClique')) {
      alert("Veuillez d'abord laisser un avis !");
      window.location.href = "index.html";
    }

    // API simul√©e c√¥t√© serveur (fallback si pas d'API Next.js)
    async function spinWheel() {
      try {
        // Essayer l'API Next.js d'abord
        const response = await fetch('/api/spin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.log("API Next.js non disponible, utilisation du fallback");
      }
      
      // Fallback c√¥t√© client
      spinCount++;
      localStorage.setItem("spinCount", spinCount);
      
      const isWinner = (spinCount % 50 === 0);
      let targetIndex;
      
      if (isWinner) {
        targetIndex = CADEAUX_INDICES[Math.floor(Math.random() * CADEAUX_INDICES.length)];
      } else {
        targetIndex = PERDU_INDICES[Math.floor(Math.random() * PERDU_INDICES.length)];
      }
      
      return { 
        targetIndex, 
        label: SEGMENTS[targetIndex], 
        spinCount,
        isWin: isWinner
      };
    }

    // Dessiner la roue
    function drawWheel() {
      const centerX = 200;
      const centerY = 200;
      const radius = 180;
      const segmentAngle = (2 * Math.PI) / SEGMENTS.length;

      ctx.clearRect(0, 0, 400, 400);

      SEGMENTS.forEach((segment, index) => {
        const startAngle = index * segmentAngle;
        const endAngle = (index + 1) * segmentAngle;

        // Dessiner segment
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = SEGMENT_COLORS[index];
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Texte centr√©
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(startAngle + segmentAngle / 2);
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 18px Inter';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(segment, radius - 25, 0);
        ctx.restore();
      });

      // Cercle central
      ctx.beginPath();
      ctx.arc(centerX, centerY, 40, 0, 2 * Math.PI);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.strokeStyle = '#1f2937';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      ctx.font = 'bold 24px Inter';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#1f2937';
      ctx.fillText('üéÅ', centerX, centerY);
    }

    // Calculer rotation finale (sans logique al√©atoire c√¥t√© front)
    function computeFinalRotation(currentRotation, targetIndex, segmentsLength, pointerOffset) {
      const segmentAngle = 360 / segmentsLength; // 45¬∞ pour 8 segments
      const targetCenter = targetIndex * segmentAngle + segmentAngle / 2; // Centre du segment cible
      
      // La fl√®che pointe vers le haut (0¬∞), donc on veut que le centre du segment arrive en haut
      // Donc on arr√™te la roue √† (360 - targetCenter + pointerOffset)
      const stopAt = 360 - targetCenter + pointerOffset;
      
      const minRotations = 5; // 5 tours minimum
      const fullTurns = minRotations * 360;
      
      // Calculer la rotation totale n√©cessaire (sans random c√¥t√© front)
      const totalRotation = fullTurns + stopAt;
      
      return totalRotation;
    }

    // Fonction utilitaire pour v√©rifier quel segment est sous la fl√®che (DEV)
    function segmentAtPointer(finalRotation) {
      const normalizedRotation = finalRotation % 360;
      const segmentAngle = 360 / SEGMENTS.length;
      
      // Calculer quel segment est sous la fl√®che (0¬∞ = haut)
      let segmentIndex = Math.floor((360 - normalizedRotation) / segmentAngle);
      segmentIndex = segmentIndex % SEGMENTS.length;
      
      if (segmentIndex < 0) segmentIndex += SEGMENTS.length;
      
      return {
        index: segmentIndex,
        label: SEGMENTS[segmentIndex]
      };
    }

    // Cr√©er confetti
    function createConfetti() {
      const colors = ['#f59e0b', '#3b82f6', '#8b5cf6', '#10b981', '#ef4444'];
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti absolute w-3 h-3';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 2 + 's';
        confettiContainer.appendChild(confetti);
        
        setTimeout(() => confetti.remove(), 5000);
      }
    }

    // Gestionnaire spin
    spinBtn.addEventListener('click', async () => {
      if (spinning) return;
      
      spinning = true;
      result.textContent = '';
      winnerForm.classList.add('hidden');
      spinBtn.disabled = true;
      spinBtn.textContent = '‚è≥ En cours...';

      try {
        // 1. Appeler l'API et r√©cup√©rer targetIndex et label
        const { targetIndex, label, spinCount: newSpinCount } = await spinWheel();
        
        console.log(`API retourne: targetIndex=${targetIndex}, label="${label}"`);
        
        // 2. Calculer la rotation finale
        const finalRotation = computeFinalRotation(currentRotation, targetIndex, SEGMENTS.length, POINTER_OFFSET);
        
        // 3. V√©rifier quel segment sera sous la fl√®che (DEV)
        const expectedSegment = segmentAtPointer(finalRotation);
        console.log(`Segment attendu sous la fl√®che: ${expectedSegment.label} (index: ${expectedSegment.index})`);
        console.log(`Label API: ${label}`);
        
        // 4. Supprimer l'effet aller-retour
        wheel.style.transition = 'none';
        wheel.style.transform = `rotate(${currentRotation % 360}deg)`;
        wheel.offsetHeight; // Force reflow
        
        // 5. Appliquer la transition
        wheel.style.transition = 'transform 3s cubic-bezier(0.16,1,0.3,1)';
        currentRotation = finalRotation;
        wheel.style.transform = `rotate(${currentRotation}deg)`;
        
        // 6. Attendre la fin de la transition
        wheel.addEventListener('transitionend', function onTransitionEnd() {
          wheel.removeEventListener('transitionend', onTransitionEnd);
          
          // 7. Afficher le label de l'API (jamais recalcul√© c√¥t√© front)
          if (label === 'Perdu') {
            result.textContent = 'Dommage, r√©essaye la prochaine fois !';
          } else {
            result.textContent = `Bravo, tu as gagn√© : ${label} üéâ`;
            createConfetti();
            winnerForm.classList.remove('hidden');
          }
          
          spinning = false;
          spinBtn.disabled = false;
          spinBtn.textContent = 'üéØ Tourner la roue';
          
          console.log(`Spin ${newSpinCount}: ${label === 'Perdu' ? 'PERDU' : 'GAGN√â'} - Label API: ${label}`);
        }, { once: true });
        
      } catch (error) {
        console.error('Erreur:', error);
        result.textContent = 'Erreur, r√©essaye !';
        spinning = false;
        spinBtn.disabled = false;
        spinBtn.textContent = 'üéØ Tourner la roue';
      }
    });

    // Gestionnaire formulaire
    winnerForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const prenom = document.getElementById('prenom').value;
      const tel = document.getElementById('tel').value;
      
      try {
        await fetch('https://mon-api.com/ajouter-gagnant', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prenom, tel, spinCount, prize: 'gagn√©' })
        });
        
        alert(`Merci ${prenom} ! Votre gain a √©t√© enregistr√©.`);
        winnerForm.classList.add('hidden');
        result.textContent = '';
        
      } catch (error) {
        console.error('Erreur envoi:', error);
        alert('Erreur lors de l\'enregistrement, mais votre gain est valid√© !');
      }
    });

    // Initialisation
    drawWheel();
  </script>
</body>
</html>
